#!/bin/bash

# Arch Linux Installation Script with Btrfs and Multiple Desktop Environments
# Features:
# - Btrfs filesystem with snapshots
# - Multiple desktop environment choices (Hyprland/KDE/GNOME/XFCE/i3/Minimal)
# - Auto-detect UEFI/BIOS boot mode
# - User disk selection with automatic partitioning
# - USTC mirrors and archlinuxcn repository
# - Minimal/optimized package installation

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    error "This script must be run as root. Please run with sudo or as root user."
    exit 1
fi

# Record start time for installation duration
START_TIME=$(date +%s)

# Get script directory for module access
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Check if modules directory exists
if [[ ! -d "$SCRIPT_DIR/modules" ]]; then
    error "Modules directory not found. Please ensure all files are in the correct location."
fi

# Run boot mode check module
log "Running boot mode detection..."
if [[ -f "$SCRIPT_DIR/modules/check-boot-mode.sh" ]]; then
    bash "$SCRIPT_DIR/modules/check-boot-mode.sh"
    echo
    echo "Press Enter to continue with installation..."
    read
fi

# Detect boot mode (UEFI or BIOS)
if [[ -d /sys/firmware/efi/efivars ]]; then
    BOOT_MODE="UEFI"
    log "Detected UEFI boot mode"
else
    BOOT_MODE="BIOS"
    log "Detected BIOS/Legacy boot mode"
fi

# Configure mirrors first for faster downloads
log "Configuring mirrors for faster downloads..."
echo

# Backup original mirrorlist
cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup

# Configure China mirrors for faster download
cat > /etc/pacman.d/mirrorlist << 'EOF'
##
## Arch Linux repository mirrorlist
## Generated by archlinux-install-btrfs script
##

## China
Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch
Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch
Server = https://mirror.lzu.edu.cn/archlinux/$repo/os/$arch

## Global
Server = https://mirror.rackspace.com/archlinux/$repo/os/$arch
Server = https://ftp.jaist.ac.jp/pub/Linux/ArchLinux/$repo/os/$arch
EOF

log "Mirrors configured successfully"

# Update package database
log "Updating package database..."
pacman -Sy

# Update system clock
log "Updating system clock..."
timedatectl set-ntp true

# Collect all user configuration before starting installation
collect_user_configuration() {
    log "=== Installation Configuration ==="
    echo

    # Display available disks and create selection menu
    log "Available disks:"
    echo

    # Get list of available disks
    mapfile -t DISKS < <(lsblk -d -n -o NAME | grep -E "sd|nvme|vd" | sed 's/^/\/dev\//')

    if [[ ${#DISKS[@]} -eq 0 ]]; then
        error "No suitable disks found!"
        exit 1
    fi

    # Display disk information
    for i in "${!DISKS[@]}"; do
        disk_info=$(lsblk -d -o NAME,SIZE,MODEL "${DISKS[$i]}" | tail -n 1)
        echo "$((i+1))) ${DISKS[$i]} - $disk_info"
    done

    echo
    echo "Select the disk to install Arch Linux:"
    echo "âš ï¸  WARNING: The selected disk will be completely wiped!"
    echo

    # Get user selection
    while true; do
        echo -n "Enter your choice (1-${#DISKS[@]}): "
        read choice

        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#DISKS[@]} ]]; then
            DISK="${DISKS[$((choice-1))]}"
            break
        else
            error "Invalid choice. Please enter a number between 1 and ${#DISKS[@]}."
        fi
    done

    log "Selected disk: $DISK"
    echo

    # Get user information
    log "Setting up user information..."
    echo

    # Username input with validation
    while true; do
        echo -n "Enter username: "
        read USERNAME

        if [[ -n "$USERNAME" ]] && [[ "$USERNAME" =~ ^[a-z_][a-z0-9_-]*$ ]] && [[ ${#USERNAME} -le 32 ]]; then
            break
        else
            error "Invalid username. Use lowercase letters, numbers, underscore, and hyphen only (max 32 chars)."
        fi
    done

    # User password input with confirmation
    while true; do
        echo -n "Enter password for $USERNAME: "
        read -s USER_PASSWORD
        echo
        echo -n "Confirm password: "
        read -s USER_PASSWORD_CONFIRM
        echo

        if [[ -n "$USER_PASSWORD" ]] && [[ "$USER_PASSWORD" == "$USER_PASSWORD_CONFIRM" ]]; then
            break
        else
            error "Passwords do not match or are empty. Please try again."
        fi
    done

    # Root password input with confirmation
    while true; do
        echo -n "Enter root password: "
        read -s ROOT_PASSWORD
        echo
        echo -n "Confirm root password: "
        read -s ROOT_PASSWORD_CONFIRM
        echo

        if [[ -n "$ROOT_PASSWORD" ]] && [[ "$ROOT_PASSWORD" == "$ROOT_PASSWORD_CONFIRM" ]]; then
            break
        else
            error "Root passwords do not match or are empty. Please try again."
        fi
    done

    # Hostname input with validation
    while true; do
        echo -n "Enter hostname: "
        read HOSTNAME

        if [[ -n "$HOSTNAME" ]] && [[ "$HOSTNAME" =~ ^[a-zA-Z0-9-]+$ ]] && [[ ${#HOSTNAME} -le 63 ]]; then
            break
        else
            error "Invalid hostname. Use letters, numbers, and hyphens only (max 63 chars)."
        fi
    done

    # Desktop environment selection
    echo
    log "Available desktop environments:"
    echo "1) Hyprland (Wayland compositor - modern, minimal)"
    echo "2) KDE Plasma (full desktop environment - feature-rich)"
    echo "3) GNOME (modern desktop - user-friendly)"
    echo "4) XFCE (lightweight desktop - stable)"
    echo "5) i3 (tiling window manager - keyboard-driven)"
    echo "6) Minimal (no desktop environment - command line only)"
    echo

    # Desktop environment selection with validation
    while true; do
        echo -n "Choose desktop environment (1-6): "
        read DE_CHOICE

        case $DE_CHOICE in
            1)
                DESKTOP_ENV="hyprland"
                log "Selected: Hyprland (Wayland compositor)"
                break
                ;;
            2)
                DESKTOP_ENV="kde"
                log "Selected: KDE Plasma (full desktop environment)"
                break
                ;;
            3)
                DESKTOP_ENV="gnome"
                log "Selected: GNOME (modern desktop)"
                break
                ;;
            4)
                DESKTOP_ENV="xfce"
                log "Selected: XFCE (lightweight desktop)"
                break
                ;;
            5)
                DESKTOP_ENV="i3"
                log "Selected: i3 (tiling window manager)"
                break
                ;;
            6)
                DESKTOP_ENV="minimal"
                log "Selected: Minimal (no desktop environment)"
                break
                ;;
            *)
                error "Invalid choice. Please enter a number between 1 and 6."
                ;;
        esac
    done

    # Final confirmation with all settings
    echo
    echo "=== Installation Summary ==="
    echo "Disk: $DISK"
    echo "Username: $USERNAME"
    echo "Hostname: $HOSTNAME"
    echo "Desktop Environment: $DESKTOP_ENV"
    echo "Boot Mode: $BOOT_MODE"
    echo
    warn "This will COMPLETELY ERASE $DISK. All data will be lost!"
    echo "âš ï¸  FINAL WARNING: This action cannot be undone!"
    echo

    # Final confirmation with explicit typing
    while true; do
        echo -n "Type 'YES' to confirm installation (or 'no' to cancel): "
        read CONFIRM

        case "$CONFIRM" in
            "YES")
                log "Installation confirmed. Starting unattended installation..."
                break
                ;;
            "no"|"NO"|"n"|"N")
                error "Installation cancelled by user."
                exit 1
                ;;
            *)
                error "Please type exactly 'YES' to confirm or 'no' to cancel."
                ;;
        esac
    done
}

# Call the configuration function
collect_user_configuration

echo
log "=== Starting Unattended Installation ==="
log "All configuration completed. The installation will now proceed automatically."
log "This process may take 20-60 minutes depending on your internet speed and hardware."
log "Please do not interrupt the installation process."
echo
log "Installation progress will be displayed below..."
echo

# Partition the disk based on boot mode
log "Partitioning disk $DISK for $BOOT_MODE mode..."

# Unmount any existing partitions on the disk
log "Unmounting any existing partitions..."
umount ${DISK}* 2>/dev/null || true
swapoff ${DISK}* 2>/dev/null || true

# Wipe disk signatures and partition table
log "Wiping disk signatures..."
wipefs -af "$DISK"
sgdisk --zap-all "$DISK" 2>/dev/null || true
dd if=/dev/zero of="$DISK" bs=1M count=100 2>/dev/null || true

# Wait for disk to settle and reload partition table
sleep 3
partprobe "$DISK" 2>/dev/null || true
sleep 2

if [[ "$BOOT_MODE" == "UEFI" ]]; then
    # UEFI partitioning scheme
    log "Creating GPT partition table for UEFI..."
    echo "  â†’ Creating GPT partition table..."
    parted -s "$DISK" mklabel gpt

    echo "  â†’ Creating EFI System Partition (512MB)..."
    parted -s "$DISK" mkpart primary fat32 1MiB 512MiB

    echo "  â†’ Setting ESP flag on EFI partition..."
    parted -s "$DISK" set 1 esp on

    echo "  â†’ Creating root partition (remaining space)..."
    parted -s "$DISK" mkpart primary btrfs 512MiB 100%

    # Wait for partitions to be created
    echo "  â†’ Waiting for partition table to be updated..."
    sleep 3
    partprobe "$DISK" 2>/dev/null || true
    sleep 2

    # Display partition table
    echo "  â†’ Partition table created:"
    parted "$DISK" print 2>/dev/null | grep -E "Number|^ *[0-9]" || true

    # Determine partition names for UEFI (improved detection)
    if [[ "$DISK" == *"nvme"* ]] || [[ "$DISK" == *"mmcblk"* ]] || [[ "$DISK" == *"loop"* ]]; then
        BOOT_PARTITION="${DISK}p1"
        ROOT_PARTITION="${DISK}p2"
    else
        BOOT_PARTITION="${DISK}1"
        ROOT_PARTITION="${DISK}2"
    fi

    # Verify partitions exist before formatting
    if [[ ! -b "$BOOT_PARTITION" ]] || [[ ! -b "$ROOT_PARTITION" ]]; then
        error "Partitions not found after creation. Boot: $BOOT_PARTITION, Root: $ROOT_PARTITION"
        exit 1
    fi

    log "EFI partition: $BOOT_PARTITION"
    log "Root partition: $ROOT_PARTITION"

    # Format partitions for UEFI
    log "Formatting partitions for UEFI..."
    echo "  â†’ Formatting EFI partition ($BOOT_PARTITION) as FAT32..."
    mkfs.fat -F32 "$BOOT_PARTITION"

    echo "  â†’ Formatting root partition ($ROOT_PARTITION) as Btrfs..."
    mkfs.btrfs -f "$ROOT_PARTITION"

else
    # BIOS partitioning scheme
    log "Creating MBR partition table for BIOS..."
    echo "  â†’ Creating MBR partition table..."
    parted -s "$DISK" mklabel msdos

    echo "  â†’ Creating root partition (full disk)..."
    parted -s "$DISK" mkpart primary btrfs 1MiB 100%

    echo "  â†’ Setting boot flag on root partition..."
    parted -s "$DISK" set 1 boot on

    # Wait for partitions to be created
    echo "  â†’ Waiting for partition table to be updated..."
    sleep 3
    partprobe "$DISK" 2>/dev/null || true
    sleep 2

    # Display partition table
    echo "  â†’ Partition table created:"
    parted "$DISK" print 2>/dev/null | grep -E "Number|^ *[0-9]" || true

    # Determine partition names for BIOS (improved detection)
    if [[ "$DISK" == *"nvme"* ]] || [[ "$DISK" == *"mmcblk"* ]] || [[ "$DISK" == *"loop"* ]]; then
        ROOT_PARTITION="${DISK}p1"
    else
        ROOT_PARTITION="${DISK}1"
    fi

    # Verify partition exists before formatting
    if [[ ! -b "$ROOT_PARTITION" ]]; then
        error "Root partition not found after creation: $ROOT_PARTITION"
        exit 1
    fi

    log "Root partition: $ROOT_PARTITION"

    # Format partitions for BIOS
    log "Formatting partitions for BIOS..."
    echo "  â†’ Formatting root partition ($ROOT_PARTITION) as Btrfs..."
    mkfs.btrfs -f "$ROOT_PARTITION"
fi

# Mount root partition and create btrfs subvolumes
log "Creating btrfs subvolumes..."

# Ensure /mnt is unmounted first
umount /mnt 2>/dev/null || true

# Mount root partition
if ! mount "$ROOT_PARTITION" /mnt; then
    error "Failed to mount root partition: $ROOT_PARTITION"
    exit 1
fi

# Create subvolumes
log "Creating btrfs subvolumes..."
echo "  â†’ Creating @ (root) subvolume..."
btrfs subvolume create /mnt/@

echo "  â†’ Creating @home (user data) subvolume..."
btrfs subvolume create /mnt/@home

echo "  â†’ Creating @var (system data) subvolume..."
btrfs subvolume create /mnt/@var

echo "  â†’ Creating @tmp (temporary files) subvolume..."
btrfs subvolume create /mnt/@tmp

echo "  â†’ Creating @snapshots (snapshots) subvolume..."
btrfs subvolume create /mnt/@snapshots

# Unmount to remount with subvolumes
umount /mnt

# Mount subvolumes
log "Mounting btrfs subvolumes..."
if ! mount -o noatime,compress=zstd,space_cache=v2,subvol=@ "$ROOT_PARTITION" /mnt; then
    error "Failed to mount root subvolume"
    exit 1
fi

# Create mount points
if [[ "$BOOT_MODE" == "UEFI" ]]; then
    mkdir -p /mnt/{boot,home,var,tmp,.snapshots}
else
    mkdir -p /mnt/{home,var,tmp,.snapshots}
fi

# Mount other subvolumes
log "Mounting additional subvolumes..."
mount -o noatime,compress=zstd,space_cache=v2,subvol=@home "$ROOT_PARTITION" /mnt/home
mount -o noatime,compress=zstd,space_cache=v2,subvol=@var "$ROOT_PARTITION" /mnt/var
mount -o noatime,compress=zstd,space_cache=v2,subvol=@tmp "$ROOT_PARTITION" /mnt/tmp
mount -o noatime,compress=zstd,space_cache=v2,subvol=@snapshots "$ROOT_PARTITION" /mnt/.snapshots

# Mount EFI partition for UEFI mode
if [[ "$BOOT_MODE" == "UEFI" ]]; then
    log "Mounting EFI partition..."
    if ! mount "$BOOT_PARTITION" /mnt/boot; then
        error "Failed to mount EFI partition: $BOOT_PARTITION"
        exit 1
    fi
fi

# Verify all mounts
log "Verifying mount points..."
if ! mountpoint -q /mnt; then
    error "Root mount point verification failed"
    exit 1
fi

# Configure USTC mirrors
log "Configuring USTC mirrors..."
cat > /etc/pacman.d/mirrorlist << 'EOF'
# USTC Mirror
Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch
# Tsinghua Mirror (backup)
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch
# Official mirrors (backup)
Server = https://geo.mirror.pkgbuild.com/$repo/os/$arch
EOF

# Install base system
echo
log "=== Step 1/5: Installing Base System ==="
log "Installing base system packages (this may take 10-20 minutes)..."
pacstrap /mnt base base-devel linux linux-firmware btrfs-progs

# Generate fstab
echo
log "=== Step 2/5: Configuring File System ==="
log "Generating fstab..."
genfstab -U /mnt >> /mnt/etc/fstab

# Create chroot script
log "Creating system configuration script..."
cat > /mnt/chroot-config.sh << EOF
#!/bin/bash

# Boot mode and disk information
BOOT_MODE="$BOOT_MODE"
DISK="$DISK"
DESKTOP_ENV="$DESKTOP_ENV"
USERNAME="$USERNAME"
HOSTNAME="$HOSTNAME"
ROOT_PASSWORD="$ROOT_PASSWORD"
USER_PASSWORD="$USER_PASSWORD"

# Function definitions for chroot environment
log() {
    echo -e "\033[0;32m[INFO]\033[0m \$1"
}

warn() {
    echo -e "\033[1;33m[WARN]\033[0m \$1"
}

error() {
    echo -e "\033[0;31m[ERROR]\033[0m \$1"
    exit 1
}

echo "Configuring timezone and locale..."
# Set timezone
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime

# Configure hardware clock for dual boot compatibility
log "Configuring hardware clock for dual boot..."
# Set hardware clock to UTC (recommended for dual boot with Windows)
hwclock --systohc --utc

# Configure systemd-timesyncd for better time synchronization
log "Configuring time synchronization..."
cat > /etc/systemd/timesyncd.conf << 'TIME_EOF'
[Time]
NTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org
FallbackNTP=0.pool.ntp.org 1.pool.ntp.org 2.pool.ntp.org 3.pool.ntp.org
RootDistanceMaxSec=5
PollIntervalMinSec=32
PollIntervalMaxSec=2048
TIME_EOF

# Enable time synchronization
systemctl enable systemd-timesyncd

# Create script to fix Windows time issues
log "Creating Windows time sync fix script..."
cat > /usr/local/bin/fix-windows-time.sh << 'WINTIME_EOF'
#!/bin/bash
# Fix Windows time synchronization issues in dual boot

echo "Fixing Windows time synchronization..."

# Set hardware clock to local time (Windows compatible)
timedatectl set-local-rtc 1 --adjust-system-clock

# Sync with NTP
timedatectl set-ntp true

# Force time sync
systemctl restart systemd-timesyncd
sleep 2

# Show current time settings
echo "Current time settings:"
timedatectl status

echo "Windows time sync fix applied!"
echo "Note: This sets hardware clock to local time for Windows compatibility."
echo "To revert to UTC: timedatectl set-local-rtc 0 --adjust-system-clock"
WINTIME_EOF

chmod +x /usr/local/bin/fix-windows-time.sh

# Configure locale
echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
echo "zh_CN.UTF-8 UTF-8" >> /etc/locale.gen
locale-gen
echo "LANG=en_US.UTF-8" > /etc/locale.conf

echo "Setting hostname and configuring mirrors..."
# Set hostname
echo "$HOSTNAME" > /etc/hostname
cat > /etc/hosts << 'HOSTS_EOF'
127.0.0.1   localhost
::1         localhost
127.0.1.1   $HOSTNAME.localdomain $HOSTNAME
HOSTS_EOF

# Configure USTC mirrors in chroot
cat > /etc/pacman.d/mirrorlist << 'MIRROR_EOF'
# USTC Mirror
Server = https://mirrors.ustc.edu.cn/archlinux/\$repo/os/\$arch
# Tsinghua Mirror (backup)
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/\$repo/os/\$arch
# Official mirrors (backup)
Server = https://geo.mirror.pkgbuild.com/\$repo/os/\$arch
MIRROR_EOF

# Update package database first
pacman -Sy --noconfirm

echo "Installing essential packages..."
# Install essential packages (including os-prober for dual boot detection)
pacman -S --noconfirm grub efibootmgr networkmanager \
    wireless_tools wpa_supplicant dialog os-prober mtools dosfstools \
    reflector git curl wget vim nano sudo zsh ntfs-3g \
    pipewire pipewire-alsa pipewire-pulse pipewire-jack wireplumber

# Install desktop environment specific packages
case "$DESKTOP_ENV" in
    "hyprland")
        log "Installing Hyprland (minimal Wayland compositor)..."
        pacman -S --noconfirm hyprland waybar wofi kitty thunar firefox \
            xdg-desktop-portal-hyprland polkit-gnome grim slurp wl-clipboard \
            brightnessctl playerctl pamixer ttf-font-awesome \
            network-manager-applet blueman sddm

        log "Enabling SDDM display manager for Hyprland..."
        systemctl enable sddm
        ;;
    "kde")
        log "Installing KDE Plasma (minimal)..."
        pacman -S --noconfirm plasma-desktop plasma-nm plasma-pa \
            konsole dolphin kate firefox sddm \
            xdg-desktop-portal-kde breeze-gtk kde-gtk-config

        log "Enabling SDDM display manager for KDE..."
        systemctl enable sddm
        ;;
    "gnome")
        log "Installing GNOME (minimal)..."
        pacman -S --noconfirm gnome-shell gnome-terminal nautilus \
            gnome-control-center gnome-session gdm firefox \
            xdg-desktop-portal-gnome gnome-keyring

        log "Enabling GDM display manager for GNOME..."
        systemctl enable gdm
        ;;
    "xfce")
        log "Installing XFCE (lightweight)..."
        pacman -S --noconfirm xfce4 xfce4-goodies sddm \
            firefox thunar-archive-plugin xarchiver

        log "Enabling SDDM display manager for XFCE..."
        systemctl enable sddm
        ;;
    "i3")
        log "Installing i3 (tiling window manager)..."
        pacman -S --noconfirm i3-wm i3status i3lock dmenu \
            xorg-server xorg-xinit sddm \
            alacritty firefox feh picom

        log "Enabling SDDM display manager for i3..."
        systemctl enable sddm
        ;;
    "minimal")
        log "Installing minimal system (no desktop environment)..."
        # Only essential packages already installed
        ;;
esac

# Install snapshot tools
pacman -S --noconfirm snapper snap-pac grub-btrfs

# Configure GRUB for dual boot support
log "Configuring GRUB with dual boot support..."

# Enable os-prober for dual boot detection
sed -i 's/#GRUB_DISABLE_OS_PROBER=false/GRUB_DISABLE_OS_PROBER=false/' /etc/default/grub
echo 'GRUB_DISABLE_OS_PROBER=false' >> /etc/default/grub

# Configure GRUB timeout for dual boot
sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=10/' /etc/default/grub

# Add Windows time sync fix to GRUB configuration
if ! grep -q "GRUB_CMDLINE_LINUX_DEFAULT.*rtc" /etc/default/grub; then
    sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT="/GRUB_CMDLINE_LINUX_DEFAULT="rtc_cmos_read_time=1 /' /etc/default/grub
fi

# Configure GRUB based on boot mode
if [[ "$BOOT_MODE" == "UEFI" ]]; then
    log "Installing GRUB for UEFI..."
    # Ensure EFI directory exists and is mounted
    if [[ ! -d /boot/EFI ]]; then
        mkdir -p /boot/EFI
    fi

    # Check if EFI partition is properly mounted
    if ! mountpoint -q /boot; then
        error "EFI partition not mounted at /boot"
        exit 1
    fi

    # Install GRUB for UEFI
    if ! grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB --recheck; then
        error "GRUB installation failed for UEFI"
        exit 1
    fi
else
    log "Installing GRUB for BIOS..."
    # Install GRUB for BIOS
    if ! grub-install --target=i386-pc "$DISK" --recheck; then
        error "GRUB installation failed for BIOS"
        exit 1
    fi
fi

# Detect other operating systems
log "Detecting other operating systems..."
os-prober || warn "No other operating systems detected or os-prober failed"

# Generate GRUB configuration with dual boot support
log "Generating GRUB configuration with dual boot support..."
if ! grub-mkconfig -o /boot/grub/grub.cfg; then
    error "GRUB configuration generation failed"
    exit 1
fi

# Check if other OS entries were added
if grep -q "Windows\|Ubuntu\|Debian\|Fedora\|openSUSE" /boot/grub/grub.cfg; then
    log "Other operating systems detected and added to GRUB menu"
else
    warn "No other operating systems found in GRUB configuration"
fi

# Enable essential services
log "Enabling essential services..."
systemctl enable NetworkManager
systemctl enable reflector.timer

# Ensure NetworkManager is properly configured
log "Configuring NetworkManager..."
# Create NetworkManager configuration for better connectivity
mkdir -p /etc/NetworkManager/conf.d
cat > /etc/NetworkManager/conf.d/20-connectivity.conf << 'NM_EOF'
[connectivity]
uri=http://www.archlinux.org/check_network_status.txt
interval=300
response=NetworkManager is online

[main]
dns=default
systemd-resolved=false
NM_EOF

# Configure DNS fallback
cat > /etc/NetworkManager/conf.d/30-dns.conf << 'NM_EOF'
[main]
dns=default

[global-dns-domain-*]
servers=8.8.8.8,8.8.4.4,1.1.1.1,1.0.0.1
NM_EOF

# Create network startup script for better connectivity
log "Creating network startup script..."
cat > /usr/local/bin/network-startup.sh << 'NET_EOF'
#!/bin/bash
# Network startup script for better connectivity

# Wait for NetworkManager to be ready
sleep 5

# Restart NetworkManager to ensure proper initialization
systemctl restart NetworkManager

# Wait for network interfaces to be ready
sleep 3

# Try to connect to any available network
nmcli device wifi rescan 2>/dev/null || true
sleep 2

# Enable all network devices
for device in \$(nmcli device | grep -E "wifi|ethernet" | awk '{print \$1}'); do
    nmcli device set \$device autoconnect yes 2>/dev/null || true
done

# Log network status
echo "\$(date): Network startup completed" >> /var/log/network-startup.log
nmcli device status >> /var/log/network-startup.log 2>&1
NET_EOF

chmod +x /usr/local/bin/network-startup.sh

# Create systemd service for network startup
cat > /etc/systemd/system/network-startup.service << 'SERVICE_EOF'
[Unit]
Description=Network Startup Script
After=NetworkManager.service
Wants=NetworkManager.service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/network-startup.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SERVICE_EOF

# Enable the network startup service
systemctl enable network-startup.service

# Set root password
echo "root:$ROOT_PASSWORD" | chpasswd

echo "Creating user account and configuring permissions..."
# Create user
useradd -m -G wheel,audio,video,optical,storage -s /bin/bash $USERNAME
echo "$USERNAME:$USER_PASSWORD" | chpasswd

# Configure sudo
echo "%wheel ALL=(ALL) ALL" >> /etc/sudoers

# Configure snapper for root subvolume
log "Configuring snapper for snapshots..."

# Check if .snapshots is mounted and unmount if necessary
if mountpoint -q /.snapshots; then
    umount /.snapshots
fi

# Remove the directory if it exists
if [[ -d /.snapshots ]]; then
    rm -rf /.snapshots
fi

# Create snapper configuration
if ! snapper -c root create-config /; then
    warn "Snapper configuration creation failed, continuing without snapshots"
else
    # Remove the automatically created subvolume
    if [[ -d /.snapshots ]]; then
        btrfs subvolume delete /.snapshots 2>/dev/null || true
    fi

    # Create directory and remount
    mkdir -p /.snapshots

    # Remount all filesystems
    if mount -a; then
        chmod 750 /.snapshots
        log "Snapper configuration completed successfully"
    else
        warn "Failed to remount filesystems, snapshots may not work properly"
    fi
fi

# Configure snapper settings
sed -i 's/^TIMELINE_CREATE=.*/TIMELINE_CREATE="yes"/' /etc/snapper/configs/root
sed -i 's/^TIMELINE_CLEANUP=.*/TIMELINE_CLEANUP="yes"/' /etc/snapper/configs/root
sed -i 's/^NUMBER_CLEANUP=.*/NUMBER_CLEANUP="yes"/' /etc/snapper/configs/root
sed -i 's/^NUMBER_MIN_AGE=.*/NUMBER_MIN_AGE="1800"/' /etc/snapper/configs/root
sed -i 's/^NUMBER_LIMIT=.*/NUMBER_LIMIT="10"/' /etc/snapper/configs/root
sed -i 's/^NUMBER_LIMIT_IMPORTANT=.*/NUMBER_LIMIT_IMPORTANT="5"/' /etc/snapper/configs/root

# Enable snapper services
systemctl enable snapper-timeline.timer
systemctl enable snapper-cleanup.timer
systemctl enable grub-btrfsd

# Create desktop environment specific configurations
case "$DESKTOP_ENV" in
    "hyprland")
        log "Creating Hyprland configuration..."
        mkdir -p /home/$USERNAME/.config/hypr
        cat > /home/$USERNAME/.config/hypr/hyprland.conf << 'HYPR_EOF'
# Hyprland Configuration

# Monitor configuration
monitor=,preferred,auto,auto

# Input configuration
input {
    kb_layout = us
    kb_variant =
    kb_model =
    kb_options =
    kb_rules =

    follow_mouse = 1

    touchpad {
        natural_scroll = no
    }

    sensitivity = 0
}

# General configuration
general {
    gaps_in = 5
    gaps_out = 20
    border_size = 2
    col.active_border = rgba(33ccffee) rgba(00ff99ee) 45deg
    col.inactive_border = rgba(595959aa)

    layout = dwindle
}

# Decoration
decoration {
    rounding = 10

    blur {
        enabled = true
        size = 3
        passes = 1
    }

    drop_shadow = yes
    shadow_range = 4
    shadow_render_power = 3
    col.shadow = rgba(1a1a1aee)
}

# Animations
animations {
    enabled = yes

    bezier = myBezier, 0.05, 0.9, 0.1, 1.05

    animation = windows, 1, 7, myBezier
    animation = windowsOut, 1, 7, default, popin 80%
    animation = border, 1, 10, default
    animation = borderangle, 1, 8, default
    animation = fade, 1, 7, default
    animation = workspaces, 1, 6, default
}

# Layout
dwindle {
    pseudotile = yes
    preserve_split = yes
}

# Window rules
windowrule = float, ^(kitty)$
windowrule = float, ^(thunar)$

# Key bindings
\$mainMod = SUPER

bind = \$mainMod, Q, exec, kitty
bind = \$mainMod, C, killactive,
bind = \$mainMod, M, exit,
bind = \$mainMod, E, exec, thunar
bind = \$mainMod, V, togglefloating,
bind = \$mainMod, R, exec, wofi --show drun
bind = \$mainMod, P, pseudo,
bind = \$mainMod, J, togglesplit,

# Move focus
bind = \$mainMod, left, movefocus, l
bind = \$mainMod, right, movefocus, r
bind = \$mainMod, up, movefocus, u
bind = \$mainMod, down, movefocus, d

# Switch workspaces
bind = \$mainMod, 1, workspace, 1
bind = \$mainMod, 2, workspace, 2
bind = \$mainMod, 3, workspace, 3
bind = \$mainMod, 4, workspace, 4
bind = \$mainMod, 5, workspace, 5
bind = \$mainMod, 6, workspace, 6
bind = \$mainMod, 7, workspace, 7
bind = \$mainMod, 8, workspace, 8
bind = \$mainMod, 9, workspace, 9
bind = \$mainMod, 0, workspace, 10

# Move active window to workspace
bind = \$mainMod SHIFT, 1, movetoworkspace, 1
bind = \$mainMod SHIFT, 2, movetoworkspace, 2
bind = \$mainMod SHIFT, 3, movetoworkspace, 3
bind = \$mainMod SHIFT, 4, movetoworkspace, 4
bind = \$mainMod SHIFT, 5, movetoworkspace, 5
bind = \$mainMod SHIFT, 6, movetoworkspace, 6
bind = \$mainMod SHIFT, 7, movetoworkspace, 7
bind = \$mainMod SHIFT, 8, movetoworkspace, 8
bind = \$mainMod SHIFT, 9, movetoworkspace, 9
bind = \$mainMod SHIFT, 0, movetoworkspace, 10

# Scroll through workspaces
bind = \$mainMod, mouse_down, workspace, e+1
bind = \$mainMod, mouse_up, workspace, e-1

# Move/resize windows
bindm = \$mainMod, mouse:272, movewindow
bindm = \$mainMod, mouse:273, resizewindow

# Volume and brightness controls
bind = , XF86AudioRaiseVolume, exec, pamixer -i 5
bind = , XF86AudioLowerVolume, exec, pamixer -d 5
bind = , XF86AudioMute, exec, pamixer -t
bind = , XF86MonBrightnessUp, exec, brightnessctl set +10%
bind = , XF86MonBrightnessDown, exec, brightnessctl set 10%-

# Screenshot
bind = \$mainMod, Print, exec, grim -g "\$(slurp)" - | wl-copy

# Autostart
exec-once = waybar
exec-once = /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
exec-once = nm-applet --indicator
exec-once = blueman-applet
HYPR_EOF
        ;;
    "kde")
        log "Creating KDE configuration..."
        # KDE will create its own config on first login
        # Set some basic preferences
        mkdir -p /home/$USERNAME/.config
        cat > /home/$USERNAME/.config/kdeglobals << 'KDE_EOF'
[General]
BrowserApplication=firefox.desktop

[KDE]
SingleClick=false
KDE_EOF
        ;;
    "gnome")
        log "Creating GNOME configuration..."
        # GNOME will create its own config on first login
        # Set some basic preferences via dconf
        mkdir -p /home/$USERNAME/.config/dconf
        ;;
    "xfce")
        log "Creating XFCE configuration..."
        mkdir -p /home/$USERNAME/.config/xfce4/xfconf/xfce-perchannel-xml
        cat > /home/$USERNAME/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-desktop.xml << 'XFCE_EOF'
<?xml version="1.0" encoding="UTF-8"?>
<channel name="xfce4-desktop" version="1.0">
  <property name="backdrop" type="empty">
    <property name="screen0" type="empty">
      <property name="monitor0" type="empty">
        <property name="workspace0" type="empty">
          <property name="color-style" type="int" value="0"/>
          <property name="image-style" type="int" value="5"/>
        </property>
      </property>
    </property>
  </property>
</channel>
XFCE_EOF
        ;;
    "i3")
        log "Creating i3 configuration..."
        mkdir -p /home/$USERNAME/.config/i3
        cat > /home/$USERNAME/.config/i3/config << 'I3_EOF'
# i3 config file (v4)
set \$mod Mod4

# Font
font pango:monospace 8

# Use Mouse+\$mod to drag floating windows
floating_modifier \$mod

# Start a terminal
bindsym \$mod+Return exec alacritty

# Kill focused window
bindsym \$mod+Shift+q kill

# Start dmenu
bindsym \$mod+d exec dmenu_run

# Change focus
bindsym \$mod+j focus left
bindsym \$mod+k focus down
bindsym \$mod+l focus up
bindsym \$mod+semicolon focus right

# Move focused window
bindsym \$mod+Shift+j move left
bindsym \$mod+Shift+k move down
bindsym \$mod+Shift+l move up
bindsym \$mod+Shift+semicolon move right

# Split orientation
bindsym \$mod+h split h
bindsym \$mod+v split v

# Fullscreen
bindsym \$mod+f fullscreen toggle

# Toggle floating
bindsym \$mod+Shift+space floating toggle

# Workspaces
bindsym \$mod+1 workspace 1
bindsym \$mod+2 workspace 2
bindsym \$mod+3 workspace 3
bindsym \$mod+4 workspace 4
bindsym \$mod+5 workspace 5

# Move to workspace
bindsym \$mod+Shift+1 move container to workspace 1
bindsym \$mod+Shift+2 move container to workspace 2
bindsym \$mod+Shift+3 move container to workspace 3
bindsym \$mod+Shift+4 move container to workspace 4
bindsym \$mod+Shift+5 move container to workspace 5

# Restart i3
bindsym \$mod+Shift+r restart

# Exit i3
bindsym \$mod+Shift+e exec "i3-nagbar -t warning -m 'Exit i3?' -b 'Yes' 'i3-msg exit'"

# Status bar
bar {
    status_command i3status
}
I3_EOF
        ;;
    "minimal")
        log "Minimal installation - no desktop configuration needed"
        ;;
esac

echo "Setting up user permissions..."
# Set ownership for user config files and home directory
if [[ "$DESKTOP_ENV" != "minimal" ]]; then
    chown -R $USERNAME:$USERNAME /home/$USERNAME/.config 2>/dev/null || true
fi

# Ensure correct ownership of entire home directory
chown -R $USERNAME:$USERNAME /home/$USERNAME

# Configure archlinuxcn repository (at the end for better stability)
log "Configuring archlinuxcn repository..."
cat >> /etc/pacman.conf << 'PACMAN_EOF'

# ArchLinuxCN Repository
[archlinuxcn]
Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch
PACMAN_EOF

# Update package database and install archlinuxcn-keyring
log "Installing archlinuxcn keyring..."
pacman -Sy --noconfirm
if ! pacman -S --noconfirm archlinuxcn-keyring; then
    warn "Failed to install archlinuxcn-keyring, removing repository..."
    # Remove the archlinuxcn section if keyring installation fails
    sed -i '/# ArchLinuxCN Repository/,/Server = https:\/\/mirrors.ustc.edu.cn\/archlinuxcn/d' /etc/pacman.conf
    pacman -Sy --noconfirm
else
    log "ArchLinuxCN repository configured successfully"
fi

EOF

chmod +x /mnt/chroot-config.sh

# Execute chroot script
echo
log "=== Step 3/5: Configuring System ==="
log "Configuring system settings, users, and bootloader..."

# Verify chroot script exists and is executable
if [[ ! -f /mnt/chroot-config.sh ]]; then
    error "Chroot configuration script not found"
    exit 1
fi

if [[ ! -x /mnt/chroot-config.sh ]]; then
    error "Chroot configuration script is not executable"
    exit 1
fi

# Verify essential mount points before chroot
log "Verifying mount points before chroot..."
if ! mountpoint -q /mnt; then
    error "Root filesystem not mounted at /mnt"
    exit 1
fi

if [[ "$BOOT_MODE" == "UEFI" ]] && ! mountpoint -q /mnt/boot; then
    error "EFI partition not mounted at /mnt/boot"
    exit 1
fi

# Execute chroot script with error handling
log "Entering chroot environment..."
if ! arch-chroot /mnt ./chroot-config.sh; then
    error "Chroot configuration failed"
    log "You may need to manually fix the installation"
    log "The system is mounted at /mnt"
    exit 1
fi

log "Chroot configuration completed successfully"

echo
log "=== Step 4/5: Installing Desktop Environment ==="
log "Installing $DESKTOP_ENV desktop environment..."

# Clean up
rm /mnt/chroot-config.sh

echo
log "=== Step 5/5: Finalizing Installation ==="
log "Installation completed successfully!"
log "Boot mode: $BOOT_MODE"
log "Please reboot and remove the installation media."
log ""
log "Post-installation notes:"
log "1. After reboot, log in as $USERNAME"

case "$DESKTOP_ENV" in
    "hyprland")
        log "2. Start Hyprland with: Hyprland"
        log "3. Use Super+Q for terminal, Super+R for app launcher"
        log "4. Network applet will auto-start (nm-applet)"
        log "5. Check network: ./modules/check-hyprland-network.sh"
        log "6. Setup network: ./modules/setup-hyprland-network.sh"
        log "7. Post-install config: ./modules/post-install-config.sh"
        ;;
    "kde")
        log "2. KDE Plasma will start automatically via SDDM"
        log "3. Customize desktop via System Settings"
        ;;
    "gnome")
        log "2. GNOME will start automatically via GDM"
        log "3. Access settings via Activities > Settings"
        ;;
    "xfce")
        log "2. XFCE will start automatically via LightDM"
        log "3. Right-click desktop for menu and settings"
        ;;
    "i3")
        log "2. i3 will start automatically via LightDM"
        log "3. Use Super+Return for terminal, Super+D for dmenu"
        ;;
    "minimal")
        log "2. Minimal system - install desktop environment as needed"
        log "3. Use 'sudo pacman -S' to install additional packages"
        ;;
esac

log ""
log "Snapshot management:"
log "- Snapshots are automatically created and managed by snapper"
log "- Create manual snapshots: sudo snapper -c root create --description 'description'"
log "- List snapshots: sudo snapper -c root list"
log "- Boot from snapshots via GRUB menu (Advanced options)"
log ""
warn "Don't forget to:"
warn "1. Configure your network connection"
warn "2. Install additional software as needed"
warn "3. Configure your desktop environment preferences"

echo
log "Available post-installation modules:"
log "1. modules/post-install-config.sh - System optimization and configuration"
log "2. modules/setup-hyprland-network.sh - Hyprland network setup (if using Hyprland)"
log "3. modules/check-hyprland-network.sh - Network connectivity check"
log "4. modules/wifi-helper.sh - WiFi connection assistant"

echo
success "ğŸ‰ Arch Linux installation completed successfully!"
echo
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                    Installation Summary                      â•‘"
echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
echo "â•‘ Total time: $(( ($(date +%s) - START_TIME) / 60 )) minutes $(( ($(date +%s) - START_TIME) % 60 )) seconds"
echo "â•‘ Disk: $DISK"
echo "â•‘ Username: $USERNAME"
echo "â•‘ Hostname: $HOSTNAME"
echo "â•‘ Desktop: $DESKTOP_ENV"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo
log "ğŸ”„ Next steps:"
log "1. Remove installation media (USB/DVD)"
log "2. Reboot: reboot"
log "3. Login with username: $USERNAME"
if [[ "$DESKTOP_ENV" != "minimal" ]]; then
    log "4. Desktop environment will start automatically"
fi
echo
log "ğŸ“¦ Post-installation modules:"
log "â€¢ ./modules/post-install-config.sh - System optimization"
if [[ "$DESKTOP_ENV" == "hyprland" ]]; then
    log "â€¢ ./modules/setup-hyprland-network.sh - Network setup"
fi
echo
warn "âš ï¸  Remove installation media before rebooting!"

echo "Press Enter to finish..."
read
